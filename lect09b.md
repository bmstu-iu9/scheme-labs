Лекция 9б. Мемоизация и нестрогие вычисления
============================================

**Мемоизация** — оптимизация, позволяющая избегать повторного вычисления функции,
вызванной с теми же аргументами, как и в один из прошлых вызовов.

В общем случае нужно мемоизировать чистые функции: детерминированные и без
побочных эффектов. Обоснование:

* Нет смысла мемоизировать функцию `(read port)` — она на каждом вызове должна
  выдавать очередное значение из файла.
* Нет смысла мемоизировать функцию `(display message)`, т.к. она должна выполнять
  побочный эффект.

Пример мемоизации «нечистой» функции. Функция `(get-messages lang-id)`
загружает из файла ресурсов сообщения программы на некотором языке. В процессе
работы программы пользователь может залезть в настройки и поменять выбранный
язык. Если функцию вызывать при каждой потребности вывести на экран сообщение,
то она будет многократно читать один и тот же файл. Если загружать все ресурсы
для всех языков в начале работы программы, то будут загружены лишние ресурсы.
Приемлемый вариант — мемоизировать вызовы `get-messages`.


**Строгие вычисления** — аргументы функции полностью вычисляются до того,
как эта функция вызывается. Вызовы процедур в Scheme всегда строгие.
Строгую стратегию вычислений часто называют call-by-value.

В случае **нестрогих вычислений** значения выражений могут вычисляться
по необходимости, их вызов может быть отложен.

Примеры нестрогих вычислений:

* `(if cond then else)` — вычисляется либо `then`, либо `else`.
* `(and …)`, `(or …)`.
* В языке Си логические операции `&&`, `||` тоже не строгие.

В теории рассматривают две разновидности нестрогих вычислений:

* call-by-name, вызов по имени — нормальная редукция в лябмда-исчислении,
* call-by-need, вызов по необходимости — ленивые вычисления.

В некотором смысле разновидность call-by-name — макроподстановка:

```Scheme
(define-syntax double
  (syntax-rules ()
    ((double x) (+ x x)))

(define-syntax ++
  (syntax-rules ()
    ((++ var) (begin (set! var (+ var 1))
                     var))))

(define x 10)

(double (++ x))  ;; выведет 23
x                ;; выведет 12
```

Вызов по имени в Алголе-60

```
function sum(i, start, end, val): real;
    integer i, start, end;
    real val;
    value start, end;
begin
  real res := 0;
  for i := start to end do
    res := res + val;

  comment почему нельзя res := (end - start + 1) * val?;

  sum := res
end;

function square(x): real;
     integer x;
begin
  square := x * x;
end;

real temperature[1 : 100];

integer k;

print(sum(k, 1, 10, square(k)));
print(sum(k, 1, 100, temperature[k]) / 100);
```



Пример стратегии `call-by-need` — ленивый язык программирования Хаскель

```Haskell
test xs = head (map (\x -> x*x) xs)
```

Будет вычисляться квадрат только самого первого элемента списка.


Примитивы Scheme для обеспечения ленивых вычислений
---------------------------------------------------

Это макрос `(delay expr)` и функция `(force promise)`. Макрос `delay`
принимает выражение и формирует обещание (promise) вычислить это
выражение, когда потребуется. `force` вычисляет этот promise, результат
мемоизируется.

В первом приближении:

```Scheme
(define-syntax delay
  (syntax-rules ()
    ((delay expr) (lambda () expr))))

(define (force promise)
  (promise))
```

С мемоизацией:

```Scheme
(define-syntax delay
  (syntax-rules ()
    ((delay expr) (list #f (lambda () expr)))))

(define (force promise)
  (if (car promise)
      (caar promise)
      (begin
        (set-car! (list ((cadr promise))))
        (caar promise))))
```
