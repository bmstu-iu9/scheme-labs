# Домашнее задание №4

## 1. Мемоизация

Реализуйте рекурсивные вычисления с использованием оптимизационных техник
&mdash; мемоизации результатов вычислений и отложенных вычислений.

**Важно!** Eсли в программе используются гигиенические макросы
и эта программа будет выполнена в среде guile 1.8.x 
(в том числе на сервере тестирования),
то следует подключить модуль поддержки таких макросов,
написав в начале программы следующую строку:

    (use-syntax (ice-9 syncase))

Реализуйте процедуру _memoized-factorial_ для
вычисления факториала по рекурсивной формуле
с мемоизацией результатов вычислений. Для мемоизации используйте
ассоциативный список (словарь), который храните в статической переменной.
Использовать для этой цели глобальную переменную _запрещается._

Примеры вызова процедур сервером тестирования:

    (begin
      (display (memoized-factorial 10)) (newline)
      (display (memoized-factorial 50)) (newline))
    
    3628800
    30414093201713378043612608166064768844377641568960512000000000000

## 2. Отложенные вычисления

Используя средства языка Scheme для отложенных вычислений,
реализуйте средства для работы с бесконечными &laquo;ленивыми&raquo; 
точечными парами и списками:

* Гигиенический макрос _(lazy-cons a b),_ конструирующий ленивую точечную пару вида
  _(значение-a . обещание-вычислить-значение-b)._
  Почему макрос в данном случае предпочтительнее процедуры?
* Процедуру _(lazy-car p),_ возвращающую значение 1-го элемента &laquo;ленивой&raquo; точечной пары _p._
* Процедуру _(lazy-cdr p),_ возвращающую значение 2-го элемента &laquo;ленивой&raquo; точечной пары _p._

На их основе определите:

* Процедуру <i>(lazy-head xs k)</i>, возвращающую значение <i>k</i> первых элементов
  &laquo;ленивого&raquo; списка <i>xs</i> в виде списка.
* Процедуру <i>(lazy-ref xs k)</i>, возвращающую значение <i>k</i>-го элементa
  &laquo;ленивого&raquo; списка <i>xs</i>.

Продемонстрируйте работу процедур на примере
бесконечного списка натуральных чисел. 
Для этого определите процедуру-генератор <i>(naturals start)</i>, 
возвращающую бесконечный &laquo;ленивый&raquo;
список натуральных чисел, начиная с числа <i>start</i>.

Примеры вызова процедур сервером тестирования:

<pre>
(display (lazy-head (naturals 10) 12)) 
(10 11 12 13 14 15 16 17 18 19 20 21)
</pre>

Реализуйте процедуру <i>(lazy-factorial n)</i>,
которая возвращает значение <i>n</i>!, получая его из
<i>n</i>-го элемента бесконечного списка факториалов.

Примеры вызова процедур сервером тестирования:

<pre>
(begin
  (display (lazy-factorial 10)) (newline)
  (display (lazy-factorial 50)) (newline))

3628800
30414093201713378043612608166064768844377641568960512000000000000
</pre>

## 3. Чтение из потока

Напишите процедуру <i>(read-words)</i>, осуществляющую чтение слов,
разделенных пробельными символами, из
стандартного потока (порта) ввода (сервер тестирования направляет в 
этот поток текстовый файл с примером). Слова в потоке разделены
одним или более пробельными символами. Также пробельные символы могут 
присутствовать перед первым словом и после последнего
слова, такие пробельные символы должны игнорироваться. 
Признак конца файла означает окончание ввода.
Процедура должна возвращать список строк (один элемент списка &mdash; 
одно слово в строке). 
Для пустого файла или файла, содержащего только пробелы, процедура должна
возвращать пустой список.

Анализ потока символов осуществляйте непосредственно при чтении файла,
для чего используйте встроенные процедуры <i>read-char</i>, <i>peek-char</i>, 
<i>eof-object?</i> и 
встроенные предикаты классификации символов.

Пример входных данных (&sdot; &mdash; пробел,  &para; &mdash; конец строки):
<pre>
&sdot;&sdot;one&sdot;two&sdot;three&sdot;&sdot;&sdot;&para;
four&sdot;five&sdot;&sdot;six&sdot;&sdot;&para;
</pre>

Результат вызова процедуры для этих входных данных:
<pre>
(read-words)
  &#8658; ("one" "two" "three" "four" "five" "six")
</pre>

## 4. Структуры (записи)

Используя средства языка Scheme для метапрограммирования, реализуйте каркас поддержки
типа данных &laquo;структура&raquo; (&laquo;запись&raquo;). Пусть объявление нового
типа &laquo;структура&raquo; осуществляется с помощью вызова
(<i>define-struct</i> <i>тип-структуры</i> (<i>имя-поля-1</i> <i>имя-поля-2</i> ... <i>имя-поля-n</i>). Тогда после объявления структуры программисту становятся доступны:

* Процедура &mdash; конструктор структуры вида (<i>make-тип-структуры</i> <i>значение-поля-1</i> <i>значение-поля-2</i> ... <i>значение-поля-n</i>), возвращающий структуру, поля которой инициализированы перечисленными значениями.
* Предикат типа вида (<i>тип-структуры?</i> <i>объект</i>), возврщающая <i>#t</i> если <i>объект</i> является структурой типа <i>тип-структуры</i> и <i>#f</i> в противном случае.
* Процедуры для получения значения каждого из полей структуры вида (<i>тип-структуры-имя-поля</i> <i>объект</i>).
* Процедуры модификации каждого из полей структуры вида (<i>set-тип-структуры-имя-поля!</i> <i>объект</i> <i>новое-значение</i>).

Пример использования каркаса:

<pre>
(define-struct pos (row col)) ; Объявление типа pos
(define p (make-pos 1 2))     ; Создание значения типа pos

(pos? p)    &#8658; #t

(pos-row p) &#8658; 1
(pos-col p) &#8658; 2

(set-pos-row! p 3) ; Изменение значения в поле row
(set-pos-col! p 4) ; Изменение значения в поле col

(pos-row p) &#8658; 3
(pos-col p) &#8658; 4
</pre>

<b>Рекомендация.</b> Для более короткой записи решения можно (но не обязательно) использовать квазицитирование (quasiquotation).

<b>Важно!</b> Если в программе используются гигиенические макросы и эта программа будет выполнена в среде guile 1.8.x (в том числе на сервере тестирования), то следует подключить модуль поддержки таких макросов, написав в начале программы следующую строку:

<pre>
(use-syntax (ice-9 syncase))
</pre>

## 5. Алгебраические типы данных

Используя средства языка Scheme для метапрограммирования, реализуйте каркас поддержки алгебраических типов данных.

Алгебраический тип данных — составной тип, получаемый путем комбинации значений других типов (полей) с помощью функций-конструкторов. Такой тип допускает различные комбинации полей — варианты. Для каждого из вариантов предусматривается свой конструктор. Все варианты типа рассматриваются как один полиморфный тип. Функции (процедуры), работающие с алгебраическим типом, предусматривают отдельные ветви вычислений для каждого из вариантов.

Пример. Необходимо вычислять периметры геометрических фигур (квадратов, прямоугольников, треугольников) и длины окружностей. Для этого в программе определен тип фигура, который может принимать значения квадрат, прямоугольник, треугольник, окружность. Значения создаются с помощью конструкторов (для каждой фигуры — свой конструктор) — процедур, принимающих в качестве аргументов длины сторон (1, 2 или 3 аргумента соответственно) или радиус (для окружности) и возвращающих значение типа фигура:

```
; Определяем тип
;
(define-data figure ((square a)
                     (rectangle a b)
                     (triangle a b c)
                     (circle r)))

; Определяем значения типа
;
(define s (square 10))
(define r (rectangle 10 20))
(define t (triangle 10 20 30))
(define c (circle 10))

; Пусть определение алгебраического типа вводит
; не только конструкторы, но и предикат этого типа:
;
(and (figure? s)
     (figure? r)
     (figure? t)
     (figure? c)) ⇒ #t
```

Функция расчета периметра или длины окружности — единая для всех фигур, принимает значение типа фигура и возвращает значение, вычисленное по формуле, выбранной в соответствии с вариантом фигуры:


```
(define pi (acos -1)) ; Для окружности
  
(define (perim f)
  (match f 
    ((square a)       (* 4 a))
    ((rectangle a b)  (* 2 (+ a b)))
    ((triangle a b c) (+ a b c))
    ((circle r)       (* 2 pi r))))
  
(perim s) ⇒ 40
(perim r) ⇒ 60
(perim t) ⇒ 60
```

Здесь `match` — сопоставление с образцом. В данном примере при вычислении `(perim s)` значение `s` будет сопоставлено с образцом `(square a)`. При этом будет осуществлена подстановка фактического значения `a`, содержащегося в `s`, на место а в выражении `(* 4 a)` справа от образца. Вычисленое значение будет возвращено из конструкции `match`.

**Рекомендации.** Для более короткой записи решения можно (но не обязательно) использовать квазицитирование (quasiquotation).
По литературе и ресурсам Интернет ознакомьтесь с тем, как работает сопоставление с образцом в других языках программирования.


## «Ачивки»

* Объяснить, как и почему работает следующий фрагмент кода:
  ```Scheme
  (((call-with-current-continuation
     (lambda (c) c))
    (lambda (x) x))
   'hello)
  ```
  Можно догадаться, что этот код печатает `hello`, но нужно объяснить почему.
  **+1 балл.**
* Написать макросы `my-let` и `my-let*` без использования эллипсисов
  (многоточий, `...`).
